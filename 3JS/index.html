<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Ensure no scrollbars */
        }
        canvas {
            display: block; /* Ensures canvas fills the window */
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script type="importmap"> 
        {
            "imports": {
                "three": "https://unpkg.com/three@0.141.0/build/three.module.js",
                "GLTFLoader" : "https://unpkg.com/three@0.141.0/examples/jsm/loaders/GLTFLoader.js",
                "OrbitControls": "https://unpkg.com/three@0.141.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
    <script type="module">
import { GLTFLoader } from 'GLTFLoader';
import * as THREE from 'three';
import { OrbitControls } from 'OrbitControls';

let scene = new THREE.Scene();
let renderer = new THREE.WebGLRenderer({
    canvas: document.querySelector('#canvas')
});

// Set the background color to white
scene.background = new THREE.Color(0xffffff);

// Set canvas size to match window size
renderer.setSize(window.innerWidth, window.innerHeight);

// Create camera with a more suitable position
let camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 10); // Move the camera closer

// Lighting setup
let ambientLight = new THREE.AmbientLight(0x404040, 1);  // Soft white light
scene.add(ambientLight);

let directionalLight = new THREE.DirectionalLight(0xffffff, 1);  // White sunlight
directionalLight.position.set(10, 10, 10).normalize();  // Positioning the light
scene.add(directionalLight);

// Add OrbitControls to allow for movement
let controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;  // Smooth out the movement
controls.dampingFactor = 0.25; // Controls the amount of damping
controls.screenSpacePanning = false; // Prevents panning the camera vertically

let loader = new GLTFLoader();
let turbineModel = null; // Declare the turbine model
let mixer = null; // Declare the mixer for animations

loader.load('wind_turbine/scene.gltf', function (gltf) {
    turbineModel = gltf.scene;
    scene.add(turbineModel);

    // Center the object if it's not already
    let box = new THREE.Box3().setFromObject(turbineModel);
    let center = box.getCenter(new THREE.Vector3());
    turbineModel.position.sub(center); // Center the model

    // Enhance materials: if no materials are applied, use MeshStandardMaterial
    turbineModel.traverse(function (child) {
        if (child.isMesh) {
            child.material = new THREE.MeshStandardMaterial({
                color: 0xffffff,   // White color for the wind turbine
                roughness: 0.5,    // Medium roughness
                metalness: 0.7,    // Give it a metallic look
                emissive: new THREE.Color(0.1, 0.1, 0.1) // Slight glow effect
            });
        }
    });

    // Setup the animation mixer
    mixer = new THREE.AnimationMixer(turbineModel);

    // Play all the animations (including 'idle' animation)
    gltf.animations.forEach((clip) => {
        if (clip.name === 'idle') {
            mixer.clipAction(clip).play();
        }
    });
});

// Adjust the camera aspect ratio on window resize
window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.render(scene, camera);
});

// Animation loop
function animate() {
    requestAnimationFrame(animate);

    if (mixer) {
        mixer.update(0.03); // Update animation mixer for smooth animation
    }

    controls.update(); // Update the controls in the animation loop
    renderer.render(scene, camera);
}

animate(); // Start the animation loop

    </script>
</body>
</html>
